day17(java 13일차)

익명클래스 -> 람다식 -> 예외처리 -> API -> Object 클래스 -> Wrapper 클래스

1. 익명클래스
   이름이 없는 클래스
   미구현된 멤버를 구현하여 일회성으로 객체를 생성하기 위해 사용한다
   익명클래스는 추상 클래스나 인터페이스를 구현할 때 유용하게 사용된다
   이를 통해 자식 클래스를 생성하여 부모 타입 변수에 저장할 필요없이 인터페이스나 추상 클래스를 구현하여 객체를 생성할 수 있다
   익명클래스는 클래스 내부에서 선언하며, 객체를 생성할 때 바로 구현해주는 방식으로 사용된다

2. 람다식(lambda)
1) 식(Expression)과 문(Statement) 차이
	식 : 조건식, 증감식, 초기식 ;
		식은 결과가 값이다. 
		java에서 값을 계산하고 결과를 반환하는 구문이다
		
	문 : 조건문, 반복문, 기타제어문 {}
		문은 값이 아니기 때문에 변수에 저장할 수 없고 매개변수로 넘겨줄 수 없다
		문은 식을 포함할 수 있다
		java에서 실행가능한 최소한의 코드 블록
		하나 이상의 식을 포함할 수 있다
		if문, for문, switch문, ...

2) 함수형 인터페이스(Functional Interface)
	단 하나의 추상 메소드를 가지고 있는 인터페이스
	@FunctionalInterface 어노테이션을 명시해주면 하나의 추상 메소드만 선언할 수 있도록 제한 할 수 있다


3) 람다식 : 익명메소드
	jdk8 이상부터 사용가능하다
	메소드를 하나의 식으로 표현한다
	람다식을 매개변수로 전달 가능하며, 변환도 가능하다
	함수형 인터페이스는 추상 메소드가 한개만 선언되기 때문에 람다싣으로 재정의 할 떄 메소드 이름이 필요없다

4) 람다식 문법
	매개변수 -> 바디
	lambdaTest 패키지에 LambdaTeat.java 참고

+) 람다식 활용
	스트림API 많이 활용
	이벤트 핸들러
	쓰레드와 비동기 처리
	커스텀함수 인터페이스
	

3. 예외처리
1) 오류의 종류
	에러(Error) : 개발자가 해결할 수 없는 문제(코드로 수습 불가)
	예외(Exception) : 개발자가 해결할 수 있는 문제(코드로 수습 가능)

2) 예외의 발생 시점
	확인된 예외(Cheked Exception, 일반예외)
		컴파일 단계에서 발생하는 예외(이클립스 빨간줄)
	미확인 예외(Uncecked Exception, 실행 예외 Runtime Exception)
		프로그램 실행 중(런타임) 발생하는 예외
	
	자바의 모든 예외클래스는 Throwable을 상속받은 클래스로 만들어지고
	예외 클래스는 Exception 클래스를 상속받는다
	실행 예외는 RuntimeException과 해당 클래스를 상속받는 자식클래스이고
   	그 밖의 예외는 모두 일반예외이다

3) 예외처리
   예외가 발생했을때 프로그램이 비정상적으로 종료되는 것을 막고 정상적으로 실행될 수 있도록 처리하는 것을 의미한다

	try{
		예외가 예상되는 코드
	}catch(예외클래스명 참조변수명){
		예외를 처리하는 명령문(예외발생시 실행할 코드)
	}catch(예외클래스명 참조변수명){
		예외를 처리하는 명령문(예외발생시 실행할 코드)
	}..{
	}finally{
		예외 발생 여부에 상관없이 무조선 실행할 코드(생략가능)
	}
	
	try블록에서 작설한 코드가 예외없이 정상실행된다면 catch블록은 실행되지 않고 finally문이 실행된다
	catch는 위에서부터 검사하므로 위에서 예외가 잡히면 다른 catch문은 건너뛰고 finally문이 실행된다

4) 예외클래스에서 제공하는 메소드
	자바에서는 발생할 수 있는 예외들을 클래스로 정의해두었다
	만약 실행 중 오류가 발생하면 해당 오류클래스의 객체가 생성된다(메모리에 할당된다)
	예외처리를 해두었다면 그 객체의 주소를 catch(예외클래스 참조변수)의 참조변수가 받게 된다
	예외클래스에는 다양한 기능을 제공한다
	
	.getMesseage() 		예외 메시지를 문자열로 반환
	.toString()		발생한 예외객체를 문자열로 반환
				생략가능(참조변수를 출력하면 자동으로 tostring()가 사용됨)
	.printStackTrace()	예외가 발생지점을 추적하며 단계별로 전부 출력함
	
	=> 예외처리를 적절하게 수행하면 프로그램의 안전성을 좊이고, 신뢰성있는 프로그램을 만들 수 있다
	
5) throws와 throw
	메소드 내부에서 예외가 발생할 때 try-catch블록으로 예외 처리하는 것이 기본이지만
	메소드를 호출한느 곳으로 예외처리를 떠넘실 수 있다

-throws : 예외 던지기, 메소드의 선언부에 사용된다
	메소드에서 발생할 수 있는 오류를 메소드를 정의하는 부분레서 처리하지 않고
	해당 메소드를 호출하는 쪽으로 던져서 메소드를 사용하는 개발자가 처리하도록 한다(상황에 맞게 예외처리하기 위함)

	ex) 접근제한자 리턴타입 메소드명() throws 예외클래스명{}
	    접근제한자 리턴타입 메소드명() throws 예외클래스명1, 예외클래스명2{}

-throw : 예외 강제 발생시키기
	ex) throw new 예외명();

6) 사용저 정의 예외 클래스
	사용자 정의 예외는 컴파일러가 체크하는 일반 예외로 선언할 수도 있도, 컴파일러가 체크하지 않는 실행예외로도 선언 할 수 있다
	
	일반예외는 Exception 클래스를 상속받는 자식클래스로 선언하고
	실행예외는 RuntimtException 클래스를 상속받는 자식 클래스로 선언한다
	
	기본생성자와 예외 메시지를 입력받는 생성잘르 선언해주거나 super()에 예외 메시지를 전달한다

	class사용자정의예외클래스명 extends Exception or RuntimeException{
		생성자(){
			super("사용자 정의 예외 메시지")
		}
	}


		


실습문제
1. Person 클래스를 상속하는 Student 클래스를 작성하기 
Person 클래스의 필수 멤버(필요한 것은 추가하여 작성)
   필드 : 이름, 나이(접근제한자 private)
   생성자 : 매개변수 모두 받는 생성자(접근제한자 public)
   점수계산메소드(접근제한자 public, 메소드명 score) => 점수가 없습니다 출력
   
Student클래스
   필드 : 점수(접근제한자 private)
   생성자 : 매개변수 모두 받는 생성자(접근제한자 public)
   점수계산메소드 오버라이딩 => 학생이름의 점수는 몇점입니다 출력

[ 조건 ] Person클래스 Student클래스의 상속구조를 추상클래스나 인터페이스 구조로 확장하기

2. 은행 계좌 프로그램
은행계좌 클래스 : Account
필드 : 잔고 balance
출금 메소드 : withdraw 매개변수1개 => 잔액보다 출금 금액이 크다면 출금불가 예외 처리 / 현재 잔고는 0원입니다. 
            출금금액의 0원이 부족하여 출금이 불가합니다. 출력
입금 메소드 : deposit 매개변수1개 => 잔액에 입급된 금액 추가 후 입금된 금액은 0원입니다. 현재 잔고는 0원입니다 출력

=> 모든 예외처리는 메소드를 사용하는 쪽으로 던지기

3. 문자열의 쉼표를 느낌표로 바꿔서 출력하는 프로그램(람다식 활용, 익명클래스 먼저 작성)
인터페이스 : StringInter
메소드   : String modify(String str);    매개변수 o , 리턴값 o      

메인 클래스 : Main
메소드 : main메소드
   String nation = "Korea,Spain,Germany,America";








































