day15(java 13일차)
복습 -> 접근제한자 -> 캐스팅 -> 추상 클래스

0. 복습 
1) 상속 
	클래스의 확장
	자식클래스명 extends 부모클래스명{
		//부모멤버, 자식멤버
	}
	단일상속만 있다
2) 생성자
	super() 	부모의 생성자
	기본생성자		매개변수가 없는 생성자
			매개변서가 없더라도 초기화는 {}영역안에서 가능함
			super() 모든 클래스이 최상위 부모 클래스 Object 클래스
			상속 관계에서는 super() 해당 부모클래스의 생성자
	매개변수가 있는 생성자
		매개변수를 통해 객체 생성시 원한느 값으로 초기화하기 위해 사용하는 생성자
		다양한 초기화 옵션은 제공하기 위해 오버로딩 가능함

3) 다형성
	하나의 것이 여러가지 형태를 가질 수 있는 성질
	오버로딩(메소드, 생성자) : 매개변수의 개수, 순서, 타입이 다르면 같은 이름으로 선언가능함
	오버라이딩(메소드) : 상속관계에서 자식클래스에서 부모클래스에 있는 메소드를 재정의함
	참조변수의 다형성(매개변수의 다형성) - 캐스팅

4) this, this(), super, super()
	this : 객체 자기자신(참조값)
	this() : 자기자신의 생성자
	super : 부모의 참조값
	super() : 부모의 생성자

5) 접근제한자
	접근 제한자		제한대상			제한범위
	public		클래스, 필드, 생성자, 메소드 	없음
	protected	필드, 생성자, 메소드		같은 패키지거나 상속관계에서 자식객체만 사용가능
	(default)	클래스, 필드, 생성자, 메소드	같은 패키지
	private		필드, 생성자, 메소드		같은 클래스

1.접근제한자
1)setter, getter(alt+shift+s+r)
	setter, getter 접근제한자는 public이다
	setter 메소드는 매개변수로 값을 저장만 해줄것 이기 때문에 리턴타입은 void
	메소드명 setter에서 set을 따오고 + 필드이름(첫글자는 대문자), 카멜표기법
	매개변수 타입은 필드타입

	geter 메소드는 값을 외부로 리턴해줘야하기 때문에 리터타입은 필드의 타입으로 설정
	메소드명은 getter에서 get을 따오고 + 필드이름(첫글자는 대무자), 카멜표기법
	리턴값은 필드값

+) 객체릐 필드(체이터)를 외부에서 마음대로 읽고 변결할 경우 객체의 무결성이 깨질 수 있다
	학생의 점수는 음수가 될 수 없는데 외부에서 음수로 변경하면 객체의 무결성이 꺠진다
	객체지향 프로그래밍에서는 직접적인 외부에서의 피드 접근을 막고 대신 메소드를 통해 필드에 접근하는 것을
	권장한다. 메소드는 데이터를 검증해서 유효한 값만 필드에 저장할 수 있기 떄문이다
	이 역할을 하는 것이 setter메소드이다
	외부에서 객체의 필드를 읽을 떄도 메소그가 필요한 경우가 있다
	필드값이 객체 외부레서 사용하기 부적절한 경우 메소드로 적절한 값을 변환하여 리턴할 수 있기 때문이다
	이런 역할릏 하는 것이 getter 메소드이다

2. fianl 클래스롸 final 메소드
	final 최종을 의미하는 키워드
	final 클래스 : 최종적인 클래스이므로 더이상 상속할 수 없는 클래스
			부모클래스가 될 수 없으므로 자식클래스를 만들 수 없다
	대표적인 클래스 : STring클래스
	
	final 메소드 : 최종작인 메소드이므로 오버라이딩을 할 수 없는 메소드가 된다
		부모클래스의 메소드에서 final을 사용하면 자식 클래스에서 재정의 할 수 없다

3. Casting ★★★★★
1) up casting
	자식값을 부모 타입으로 형변환(자동 타입 변환)
	부모타입 참조변수 = 자식타입 객체;

	부모클래스 타입의 참조변수로 자식 클래스의 객체를 가리킬 수 있다
	업 캐스팅 후에는 부모 클래스의 멤버(필드와 메소드)에만 접근할 수 있다
	자식 클래스의 멤버는 참조할 수 없지만 객체 내부에는 여전히 자식 클래스릐 멤버가 존재한다
	명시적 캐스팅이 생략 가능
	
	부모클래스타입 참조변수 = (부모클래스타입) new 자식클래스생성자();
	부모클래스타입 참조변수 = (부모클래스 타입) 자식객체;
	부모클래스타입 참조변수 = new 자식클래스생성자();

2)down casting
	이미 up casting 된 객체를 자식 타입으로 형 변환
	※부모 값을 자식 타입으로 형 변환시 오류발생
	※자식 클래스 타입의 객체는 부모 클래스 타입도 동시에 갖는다

	업 캐스팅된 객체를 다시 자식 클래스 타입으로 변환하는 것을 의미하며
	명시적 캐스팅이 필요하다
	다운 캐스팅 후에는 자식클래스의 멤버(필드와 메소드)에 접근할 수 있다
	잘못된 다운캐스팅(자식타입의 객체에 부모 타입의 주소값을 저장, 부모객체를 자식타입으로 변환시도)는
	ClassCastExveption 예외가 발생한다

3) Casting을 사용하는 이유
	부모타입인 하니의 저장공간에 여러 자식 타입의 참조값을 업 캐스팅하여 저장할 수 있다(참조변수의 다형성)
	만약 하나의 기능을 하는 메소드를 만들 때 매개변수로 여러 자식타입을 각각 받아야한다고 가정해보자
	Casting이 없었다면 자식 타입을 매개변수로 받는 메소그를 타입녈로 각각만들어야한다
	(자식끼리는 타입이 다르기 때문이다)
	Casting을 활용하면 부모타입의 매개변수를 가진 하나의 메소드만 만들면 된다
	(부모타입의 참조변수호 모든 자식 타입을 저장할 수 있기 때문이다)

※주의사항
	-업 캐스팅된자식의 참조값을 저장했다면 자식 클래스에 오버라이딩된 기능이 실행된다
	-업 캐스팅된 자식의 탐조값을 저장했다면 자식 클래스에서 구현한 기능들은 사용할 수 없다
	이 경우 Down Cadting을 통해서 복구하고 사용한다
	
4) 다형성
	하나의 것이 여러가지 형태를 가질 수 있는 성질
   - 오버로딩 : 생성자, 메소드
		같은 이름으로 매개변수의 타입, 순서, 개수가 다르면 선언할 수 없다
		반환타입은 영향을 끼치지 않는다
   - 오버라이딩 : 상속받은 자식 클래스의 메소드 메소드
		부모클래스에 정의된 메소드 선ㅇ언부를 그대로 쓰고 구현부만 재정의한다
		선언부는 무조건 똑같아야한다
   - 참조변수의 다형성(매개변수의 다형성) : 메소드 매개변수(상속 관계에서 부모클래스 타입)
		부모 클래스타입의 참조변수로 자식 클래스 객체를 가리키는 것을 허용하는 것을 의미한다

5) 객체 간 타입비교
	객체명 instanceof 클래스타입
	a instanceof A : 조건식, 침/거짓 중 하나가 나오는 식 true or false
		a 가 A클래스 타입이면 true
		a 가 A클래스 타입이 아니면 false

===================================


과제 
부모클래스 : Person
자식클래스 : Student, Teacher, Employee

공통메소드 : introduce() 자식클래스에서는 오버라이딩
모든 필드는 private
생성자는 이름을 갖고있는 생성자

Person 클래스
필드 : 이름,나이, 생년월일(8자리)
메소드 : introduce() 이름, 나이입니다 출력


Student 클래스
필드 : boolean stu
생성자 : 매개변수 stu도 포함
메소드 : study()
	이름이 공부을 합니다 출력
메소드 오버라이딩 : 이름은 학생입니다 출력

Teacher 클래스
필드 : x
메소드 : tech()
	이름이 가르칩니다 출력
메소드 오버라이딩 : 저는 선생님입니다 출력

Employee 클래스
필드 : x
메소드 : work()
	업무를 처리중입니다 출력
메소드 오버라이딩 : 저의 이름은 ~이고 회사원입니다 출력

Main 클래스
static 메소드(printInfo())
객체 타입에 따라 다운 캐스팅하여 전용 메소드 실행


























